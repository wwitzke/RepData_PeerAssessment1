---
title: "Reproducible Research: Peer Assessment 1"
output: 
  html_document:
    keep_md: true
---


## Loading and preprocessing the data

### Globals
Our code presumes that there is some structure to the directory in which the
analysis is being performed. This structure is defined here.
```{r global_options}
tidydata.dir = "data";
rawdata.dir = "raw";

#   So, it turns out that the default figure path for me was made out of
#   INSANITY.
knitr::opts_chunk$set( fig.path = "figure/" );

```

### GetRawFile function
This function would normally appear in an external R-code file, but for clarity
I have included it here. This function will fetch a file from an online
location, timestamp it, and then return the timestamp. It only does this if the
`output.file` doesn't already exist. If it does, then it will merely return the
timestamp for the already saved raw data set.

This function will also create the raw data directory, if necessary.
```{r GetRawFile_function}
GetRawFile = function( url, output.file = "RawData" )
{
    if ( !dir.exists( rawdata.dir ) )
    {
        dir.create( rawdata.dir, recursive = TRUE );
    }

    output.file = file.path( rawdata.dir, output.file );

    timestamp = "";
    timestamp.file = paste( output.file, "timestamp", sep = "." );

    #   Get the file from the Webosphere.
    if ( !file.exists( output.file ) )
    {
        message( "Downloading raw data." );
        timestamp = date();
        download.file(
            url = url,
            destfile = output.file
        );
        writeLines( timestamp, timestamp.file );
    }
    else
    {
        message( "Using existing raw data." );
        timestamp = readLines( timestamp.file );
    }

    #   We're going to try to unzip the raw data file. If it doesn't work and
    #        we get a warning, we are going to ignore it. That should only happen if
    #        the unzipped files already exist, or in the case that the raw data file
    #        was not zipped to begin with. At least, we hope those are the only
    #        conditions where a warning would be generated.
    suppressWarnings(
        unzip( output.file, overwrite = FALSE, exdir = rawdata.dir )
    );

    #        An argument could be made that unzipping the file should really be done
    #        in a function that tidies the data. After all, the files paths
    #        generated by this call are needed in any data tidying routine, to read
    #        the files in properly for processing. But, I don't think there is any
    #        truly generic data tidying routine possible. In every case where you
    #        are attempting to tidy data, you need to already have knowledge of the
    #        filenames for each raw data file outside of any programmatic generation
    #        of that information simply because each file will likely need very
    #        different treatment. So, there really isn't any need to pass the output
    #        of the unzip routine along. Rather, what is important here is that
    #        the code for downloading and unzipping files leaves the directory
    #        structure in a set state that can then be exploited by the software
    #        developer in writing a data tidying routine.

    return(timestamp);
}
```

Now, we actually will get and timestamp the raw data.
```{r get_raw_file}
cat(
    "Raw data downloaded on",
    GetRawFile("https://d396qusza40orc.cloudfront.net/repdata%2Fdata%2Factivity.zip"),
    "\n"
);
```

### TidyData function
This function will, if necessary, prepare the dataset for use in the analysis
and save off the data to an rds file. It returns a dplyr data frame, either the
data frame it just generated, or one that was already available. It also
creates the `tidydata.dir` if it does not already exist.

Note that this function cannot simply be dropped into another program without
significant changes, because the process of tidying data is too intimate to the
raw data format (in general).

We are going to be using the `data.table` package for this.
```{r TidyData_function}
library(data.table);
TidyData = function( rawfile = "RawData", tidyfile = "TidyData.rds" )
{
    retval = NA;
    retfile = file.path( tidydata.dir, tidyfile );

    if ( !dir.exists( tidydata.dir ) )
    {
        dir.create( tidydata.dir, recursive = TRUE );
    }

    if ( !file.exists( retfile ) )
    {
        message( "Creating tidy data set." );
        retval = fread( file.path( rawdata.dir, "activity.csv" ) );

        retval$date = as.Date( retval$date );

        saveRDS( retval, retfile );

        return( invisible( retval ) );
    }
    else
    {
        message( "Reading saved tidy data set." );
        return( invisible( readRDS( retfile ) ) );
    }
}
```
Now, we actually prepare the data and take a quick look at it.

```{r make_tidy_data}
steps.table= TidyData();
str(steps.table);
head(steps.table);

```

## What is mean total number of steps taken per day?

To calculate the total steps taken per day, we can group our `steps.table` by
date. We can also take a look at the distribution of the total steps by
generating a histogram.

```{r steps_histogram}
steps.by.date =
    steps.table[, list(total.steps = sum(steps, na.rm = TRUE)), by = date];

head( steps.by.date );

summary( steps.by.date$total.steps, na.rm = TRUE );

steps.mean.by.date = steps.by.date[ , mean(total.steps, na.rm = TRUE) ];
steps.median.by.date = steps.by.date[ , median(total.steps, na.rm = TRUE) ];

library( ggplot2 );

gg.hist.steps =
    ggplot( steps.by.date, aes( total.steps ), show.legend = TRUE ) +
    geom_histogram( bins = 20, col="black", aes( fill=..count.. ) ) +
    labs( x = "Total Steps per Day", y = "Count" ) +
    labs( title = "Occurances of Total Steps Taken in One Day" ) +
    geom_vline(
        aes(
            xintercept = steps.mean.by.date,
            color = "Mean"
        ),
        size = 1,
        show.legend = TRUE
    ) +
    geom_vline(
        aes(
            xintercept = steps.median.by.date,
            color = "Median"
        ),
        size = 1,
        show.legend = TRUE
    ) +
    scale_color_manual(
        name = "",
        values = c( Mean = "red", Median = "green" )
    );
               

print( gg.hist.steps );

```
The mean and median total steps per day are:

```{r steps_mean_median, results = 'hold'}
cat( "The mean total steps per day is", steps.mean.by.date, "\n" );
cat( "The median total steps per day is", steps.median.by.date, "\n" );
```

## What is the average daily activity pattern?

To determine average daily activity patterns, we can simply group by interval.

```{r steps_time_series}
steps.by.interval =
    steps.table[, list(mean.steps = mean(steps, na.rm = TRUE)), by = interval];

head( steps.by.interval );

summary( steps.by.interval$mean.steps, na.rm = TRUE );

steps.max.interval =
    steps.by.interval[ mean.steps == max(mean.steps, na.rm = TRUE), interval ];

library( ggplot2 );

gg.mean.steps =
    ggplot( steps.by.interval, aes( interval, mean.steps ) ) +
    geom_line( color = "cyan3" ) +
    labs( x = "Interval", y = "Number of Steps" ) +
    labs( title = "Average Daily Activity Pattern" );

print( gg.mean.steps );

cat(
    "The maximum average steps occurs during the interval at minute",
    steps.max.interval,
    "\n"
);

```

## Imputing missing values

There may be some bias introduced into the dataset due to missing values. So,
how many missing values do we have?

```{r missing_values, results = 'hold'}
cat( "Missing steps", sum(is.na( steps.table$steps )), "\n");
cat( "Missing dates", sum(is.na( steps.table$date )), "\n");
cat( "Missing intervals", sum(is.na( steps.table$interval )), "\n");

cat(
    "Proportion of missing steps is",
    sum( is.na( steps.table$steps ) )/nrow( steps.table ),
    "\n"
);

```
So, only steps are missing from the dataset, which is good, but over 13% of
entries for steps are `NA`, which may be very bad. We can estimate what these
missing values might be by replacing them with the median steps for that
interval. Apparently both mean and median are not good choices for imputation,
but in this assignment we are allowed to use simple imputed values. I choose
median because this dataset appears to have some skew in it.

```{r fix_missing_steps}

steps.table.fixed = data.table::copy(steps.table);
steps.table.fixed[ ,
    steps := ifelse(is.na(steps), median(steps, na.rm = TRUE), steps),
    by = interval
];

str(steps.table.fixed);

summary(steps.table$steps);
summary(steps.table.fixed$steps);

```
Now, we create a histogram similar to the one created earlier.

```{r fixed_steps_histogram}
steps.by.date.fixed =
    steps.table.fixed[ , list(total.steps = sum(steps)), by = date ];

head( steps.by.date.fixed );

summary( steps.by.date.fixed$total.steps );

steps.mean.by.date.fixed = steps.by.date.fixed[ , mean(total.steps) ];
steps.median.by.date.fixed = steps.by.date.fixed[ , median(total.steps) ];

library( ggplot2 );

gg.hist.steps.fixed =
    ggplot( steps.by.date.fixed, aes( total.steps ), show.legend = TRUE ) +
    geom_histogram( bins = 20, col="black", aes( fill=..count.. ) ) +
    labs( x = "Total Steps per Day", y = "Count" ) +
    labs( title = "Occurances of Total Steps Taken in One Day (with imputation)" ) +
    geom_vline(
        aes(
            xintercept = steps.mean.by.date.fixed,
            color = "Mean"
        ),
        size = 1,
        show.legend = TRUE
    ) +
    geom_vline(
        aes(
            xintercept = steps.median.by.date.fixed,
            color = "Median"
        ),
        size = 1,
        show.legend = TRUE
    ) +
    scale_color_manual(
        name = "",
        values = c( Mean = "red", Median = "green" )
    );
               

print( gg.hist.steps.fixed );

```

Our new mean and median are:

```{r steps_mean_median_fixed, results = 'hold'}

cat( "The mean fixed total steps per day is", steps.mean.by.date.fixed, "\n" );
cat(
    "The median fixed total steps per day is",
    steps.median.by.date.fixed,
    "\n"
);
```

To remind ourselves of the original values:
```{r steps_mean_median_reminder, results = 'hold'}

cat( "The mean total steps per day is", steps.mean.by.date, "\n" );
cat( "The median total steps per day is", steps.median.by.date, "\n" );
```

So, imputation using the median by interval changes the mean total daily steps
so that it is slightly higher, by about 200 steps, and does not change the
median number of steps per day.

## Are there differences in activity patterns between weekdays and weekends?

We can determine this by creating a new factor for `steps.table.fixed`. 

```{r factor_steps_fixed_time_series}
steps.table.fixed[ ,
    daytype :=
        ifelse(
            weekdays(date) %in% c("Saturday","Sunday"),
            "Weekend",
            "Weekday"
        )
];
steps.table.fixed[ , daytype := factor(daytype) ];

str(steps.table.fixed);
print(steps.table.fixed);

steps.by.interval.daytype =
    steps.table.fixed[ ,
        list(mean.steps = mean(steps)),
        by = "interval,daytype"
];

head( steps.by.interval.daytype );

summary( steps.by.interval.daytype$mean.steps );

library( ggplot2 );

gg.mean.steps.fixed =
    ggplot( steps.by.interval.daytype, aes( interval, mean.steps ) ) +
    geom_line( aes( color = daytype), show.legend = FALSE ) +
    facet_grid( daytype ~ . ) +
    labs( x = "Interval", y = "Number of Steps" ) +
    labs( title = "Average Daily Activity Pattern" );

print( gg.mean.steps.fixed );

```

